// @sts-nocheck
import { existsSync, promises as fs } from "fs";
import { tmpdir } from "os";
import path from "path";
import { cwd } from "process";
import { rimraf } from "rimraf";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import { fixImport } from "./fix-import.mts";

const forms: any = [
  {
    type: "registry:form",
    name: "identify-and-password",
    link: "sign-in",
    files: [
      {
        path: "forms/identify-and-password/sign-in/page.tsx",
        target: "app/sign-in/page.tsx",
        type: "registry:page",
      },
      {
        path: "forms/identify-and-password/sign-up/page.tsx",
        target: "app/sign-up/page.tsx",
        type: "registry:page",
      },
      {
        path: "forms/identify-and-password/sign-in/sign-in-form.tsx",
        type: "registry:component",
        target: "components/forms/identify-and-password/sign-in-form.tsx",
      },
      {
        path: "forms/identify-and-password/sign-up/sign-up-form.tsx",
        type: "registry:component",
        target: "components/forms/identify-and-password/sign-up-form.tsx",
      },
    ],
  },
  {
    type: "registry:form",
    name: "sign-up",
    link: "sign-up",
    files: [
      {
        path: "forms/identify-and-password/sign-up/page.tsx",
        target: "app/sign-up/page.tsx",
        type: "registry:page",
      },
    ],
    isDummy: true,
  },
];

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

const project = new Project({
  compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
  return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: any) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`;
  for (const item of registry) {
    const resolveFiles = item.files?.map(
      (file) => `registry/${typeof file === "string" ? file : file.path}`
    );
    if (!resolveFiles) {
      continue;
    }

    const type = item.type.split(":")[1];
    let sourceFilename = "";

    let chunks: any = [];
    if (item.type === "registry:forms") {
      const file = resolveFiles[0];
      const filename = path.basename(file);
      let raw: string;
      try {
        raw = await fs.readFile(file, "utf8");
      } catch (error) {
        continue;
      }
      const tempFile = await createTempSourceFile(filename);
      const sourceFile = project.createSourceFile(tempFile, raw, {
        scriptKind: ScriptKind.TSX,
      });

      const description = sourceFile
        .getVariableDeclaration("description")
        ?.getInitializerOrThrow()
        .asKindOrThrow(SyntaxKind.StringLiteral)
        .getLiteralValue();

      item.description = description ?? "";

      // Find all imports.
      const imports = new Map<
        string,
        {
          module: string;
          text: string;
          isDefault?: boolean;
        }
      >();
      sourceFile.getImportDeclarations().forEach((node) => {
        const module = node.getModuleSpecifier().getLiteralValue();
        node.getNamedImports().forEach((item) => {
          imports.set(item.getText(), {
            module,
            text: node.getText(),
          });
        });

        const defaultImport = node.getDefaultImport();
        if (defaultImport) {
          imports.set(defaultImport.getText(), {
            module,
            text: defaultImport.getText(),
            isDefault: true,
          });
        }
      });

      // Find all opening tags with x-chunk attribute.
      const components = sourceFile
        .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
        .filter((node) => {
          return node.getAttribute("x-chunk") !== undefined;
        });

      chunks = await Promise.all(
        components.map(async (component, index) => {
          const chunkName = `${item.name}-chunk-${index}`;

          // Get the value of x-chunk attribute.
          const attr = component
            .getAttributeOrThrow("x-chunk")
            .asKindOrThrow(SyntaxKind.JsxAttribute);

          const description = attr
            .getInitializerOrThrow()
            .asKindOrThrow(SyntaxKind.StringLiteral)
            .getLiteralValue();

          // Delete the x-chunk attribute.
          attr.remove();

          // Add a new attribute to the component.
          component.addAttribute({
            name: "x-chunk",
            initializer: `"${chunkName}"`,
          });

          // Get the value of x-chunk-container attribute.
          const containerAttr = component
            .getAttribute("x-chunk-container")
            ?.asKindOrThrow(SyntaxKind.JsxAttribute);

          const containerClassName = containerAttr
            ?.getInitializer()
            ?.asKindOrThrow(SyntaxKind.StringLiteral)
            .getLiteralValue();

          containerAttr?.remove();

          const parentJsxElement = component.getParentIfKindOrThrow(
            SyntaxKind.JsxElement
          );

          // Find all opening tags on component.
          const children = parentJsxElement
            .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
            .map((node) => {
              return node.getTagNameNode().getText();
            })
            .concat(
              parentJsxElement
                .getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement)
                .map((node) => {
                  return node.getTagNameNode().getText();
                })
            );

          const componentImports = new Map<
            string,
            string | string[] | Set<string>
          >();
          children.forEach((child) => {
            const importLine = imports.get(child);
            if (importLine) {
              const imports = componentImports.get(importLine.module) || [];

              const newImports = importLine.isDefault
                ? importLine.text
                : new Set([...imports, child]);

              componentImports.set(
                importLine.module,
                importLine?.isDefault ? newImports : Array.from(newImports)
              );
            }
          });

          const componnetImportLines = Array.from(componentImports.keys()).map(
            (key) => {
              const values = componentImports.get(key);
              const specifier = Array.isArray(values)
                ? `{${values.join(",")}}`
                : values;

              return `import ${specifier} from "${key}"`;
            }
          );

          const code = `
            'use client'

            ${componnetImportLines.join("\n")}

            export default function Component() {
              return (${parentJsxElement.getText()})
            }`;

          const targetFile = file.replace(item.name, `${chunkName}`);
          const targetFilePath = path.join(
            cwd(),
            `registry/${type}/${chunkName}.tsx`
          );

          // Write component file.
          rimraf.sync(targetFilePath);
          await fs.writeFile(targetFilePath, code, "utf8");

          return {
            name: chunkName,
            description,
            component: `React.lazy(() => import("@/registry/${type}/${chunkName}")),`,
            file: targetFile,
            container: {
              className: containerClassName,
            },
          };
        })
      );

      // // Write the source file for blocks only.
      sourceFilename = `src/__registry__/${type}/${item.name}.tsx`;

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file
        );
        if (files?.length) {
          sourceFilename = `__registry__/${files[0].path}`;
        }
      }

      const sourcePath = path.join(process.cwd(), sourceFilename);
      if (!existsSync(sourcePath)) {
        await fs.mkdir(sourcePath, { recursive: true });
      }

      rimraf.sync(sourcePath);
      await fs.writeFile(sourcePath, sourceFile.getText());
    }

    let componentPath = `@/registry/${type}/${item.name}`;

    if (item.files) {
      const files = item.files.map((file) =>
        typeof file === "string" ? { type: "registry:page", path: file } : file
      );
      if (files?.length) {
        componentPath = `@/registry/${files[0].path}`;
      }
    }
    const isDummy = item.isDummy ?? false;

    index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      link: "${item.link ?? ""}",
      files: [${item.files?.map((file) => {
        const filePath = `src/registry/${
          typeof file === "string" ? file : file.path
        }`;
        const resolvedFilePath = path.resolve(filePath);
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`;
      })}],
      component: React.lazy(() => import("${componentPath}")),
      source: "${sourceFilename}",
      category: "${item.category ?? ""}",
      subcategory: "${item.subcategory ?? ""}",
      isDummy: ${isDummy},
      chunks: [${chunks.map(
        (chunk) => `{
        name: "${chunk.name}",
        description: "${chunk.description ?? "No description"}",
        component: ${chunk.component}
        file: "${chunk.file}",
        container: {
          className: "${chunk.container.className}"
        }
      }`
      )}]
    },`;
  }

  index += `
}
`;

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry
    .filter((item) => ["registry:form"].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === "string"
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file;

          return file;
        }),
      };
    });
  const registryJson = JSON.stringify(items, null, 2);
  //   console.log(registryJson);

  rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    registryJson,
    "utf8"
  );

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "src/__registry__/index.tsx"));
  await fs.writeFile(
    path.join(process.cwd(), "src/__registry__/index.tsx"),
    index
  );
}

async function buildStyles(registry: any) {
  const targetPath = path.join(REGISTRY_PATH, "styles");

  // Create directory if it doesn't exist.
  if (!existsSync(targetPath)) {
    await fs.mkdir(targetPath, { recursive: true });
  }

  for (const item of registry) {
    // if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
    //   continue;
    // }
    if (item.isDummy) {
      continue;
    }

    let files;
    if (item.files) {
      files = await Promise.all(
        item.files
          .filter((file) => file.type === "registry:component")
          .map(async (_file) => {
            console.log(_file);

            const file =
              typeof _file === "string"
                ? {
                    path: _file,
                    type: item.type,
                    content: "",
                    target: "",
                  }
                : _file;

            let content: string;
            try {
              content = await fs.readFile(
                path.join(process.cwd(), "src/registry", file.path),
                "utf8"
              );
              content = fixImport(content);
            } catch (error) {
              return;
            }

            const tempFile = await createTempSourceFile(file.path);
            const sourceFile = project.createSourceFile(tempFile, content, {
              scriptKind: ScriptKind.TSX,
            });

            sourceFile.getVariableDeclaration("iframeHeight")?.remove();
            sourceFile.getVariableDeclaration("containerClassName")?.remove();
            sourceFile.getVariableDeclaration("description")?.remove();

            let target = file.target || "";

            if ((!target || target === "") && item.name.startsWith("v0-")) {
              const fileName = file.path.split("/").pop();
              if (
                file.type === "registry:block" ||
                file.type === "registry:component" ||
                file.type === "registry:example"
              ) {
                target = `components/${fileName}`;
              }

              if (file.type === "registry:ui") {
                target = `components/ui/${fileName}`;
              }

              if (file.type === "registry:hook") {
                target = `hooks/${fileName}`;
              }

              if (file.type === "registry:lib") {
                target = `lib/${fileName}`;
              }
            }

            return {
              path: file.path,
              type: file.type,
              content: sourceFile.getText(),
              target,
            };
          })
      );
    }

    // const payload = registryEntrySchema
    //   .omit({
    //     source: true,
    //     category: true,
    //     subcategory: true,
    //     chunks: true,
    //   })
    //   .safeParse({
    //     ...item,
    //     files,
    //   });

    // if (payload.success) {
    await fs.writeFile(
      path.join(targetPath, `${item.name}.json`),
      JSON.stringify({ ...item, files }, null, 2),
      "utf8"
    );
    // }
  }

  // ----------------------------------------------------------------------------
  // Build registry/styles/index.json.
  // ----------------------------------------------------------------------------
  // const stylesJson = JSON.stringify(styles, null, 2)
  // await fs.writeFile(
  //   path.join(REGISTRY_PATH, "styles/index.json"),
  //   stylesJson,
  //   "utf8"
  // )
}

try {
  const result = forms;
  //   if (!result.success) {
  //     console.error(result.error)
  //     process.exit(1)
  //   }

  await buildRegistry(result);
  await buildStyles(result);
  //   console.log(result.data);

  console.log("âœ… Done!");
} catch (error) {
  console.error(error);
  process.exit(1);
}
